{"version":3,"file":"batchLogRecordProcessor.js","sourceRoot":"","sources":["../../../src/logs/batchLogRecordProcessor.ts"],"names":[],"mappings":"AAAA,uCAAuC;AACvC,kCAAkC;AAElC,OAAO,EAAE,UAAU,EAAE,MAAM,oBAAoB,CAAC;AAChD,OAAO,EAAa,uBAAuB,EAAqB,MAAM,yBAAyB,CAAC;AAEhG;;;GAGG;AACH,MAAM,OAAO,4BAA6B,SAAQ,uBAAuB;IAGvE,YACE,QAA2B,EAC3B,OAAiE;QAEjE,KAAK,CAAC,QAAQ,CAAC,CAAC;QAChB,IAAI,CAAC,QAAQ,GAAG,OAAO,CAAC;IAC1B,CAAC;IAEM,MAAM,CAAC,SAAoB;QAChC,gCAAgC;QAChC,IAAI,IAAI,CAAC,QAAQ,CAAC,+BAA+B,EAAE,CAAC;YAClD,IAAI,SAAS,CAAC,WAAW,IAAI,SAAS,CAAC,WAAW,CAAC,MAAM,EAAE,CAAC;gBAC1D,IAAI,SAAS,CAAC,WAAW,CAAC,UAAU,IAAI,UAAU,CAAC,OAAO,EAAE,CAAC;oBAC3D,oDAAoD;oBACpD,OAAO;gBACT,CAAC;YACH,CAAC;QACH,CAAC;QACD,8CAA8C;QAC9C,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,SAAS,CAAC,UAAU,CAAC,EAAE,CAAC;YAChE,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;gBAC9B,SAAS,CAAC,UAAU,CAAC,GAAG,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;YACpD,CAAC;QACH,CAAC;QACD,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC;IAC1B,CAAC;CACF","sourcesContent":["// Copyright (c) Microsoft Corporation.\n// Licensed under the MIT license.\n\nimport { TraceFlags } from \"@opentelemetry/api\";\nimport { LogRecord, BatchLogRecordProcessor, LogRecordExporter } from \"@opentelemetry/sdk-logs\";\n\n/**\n * Azure Monitor BatchLogRecord Processor.\n * @internal\n */\nexport class AzureBatchLogRecordProcessor extends BatchLogRecordProcessor {\n  private readonly _options: { enableTraceBasedSamplingForLogs: boolean | undefined };\n\n  constructor(\n    exporter: LogRecordExporter,\n    options: { enableTraceBasedSamplingForLogs: boolean | undefined },\n  ) {\n    super(exporter);\n    this._options = options;\n  }\n\n  public onEmit(logRecord: LogRecord): void {\n    // Trace based sampling for logs\n    if (this._options.enableTraceBasedSamplingForLogs) {\n      if (logRecord.spanContext && logRecord.spanContext.spanId) {\n        if (logRecord.spanContext.traceFlags != TraceFlags.SAMPLED) {\n          // Do not export log for spans that were sampled out\n          return;\n        }\n      }\n    }\n    // Ensure nested log attributes are serialized\n    for (const [key, value] of Object.entries(logRecord.attributes)) {\n      if (typeof value === \"object\") {\n        logRecord.attributes[key] = JSON.stringify(value);\n      }\n    }\n    super.onEmit(logRecord);\n  }\n}\n"]}